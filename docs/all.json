{"shell":true,"revision":"639d9159b7c73f9d4fdd812193ca558ed267255d","objects":[{"type":null,"source":"lib/map_diff.ex:2","object_type":"ModuleObject","moduledoc":"Calculates the difference between two (nested) maps.\n\nThe idea is very simple:\nOne of four things can happen to each key in a map:\n\n- It remains the same: `:equal`\n- It was not in the original map, but it is in the new one: `:added`\n- It was in the original map, but is no longer in the new one: `:removed`\n- It is in both maps, but its value changed.\n\nFor the fourth variant, MapDiff.diff/2 returns `:primitive_change`\nif the value under the key was 'simply changed',\nand `:map_change` if in both arguments this value itself is a map,\nwhich means that `MapDiff.diff/2` was called on it recursively.\n\n","module":"Elixir.MapDiff","id":"MapDiff"},{"type":"def","source":"lib/map_diff.ex:20","signature":[["a",[],null],["a",[],null]],"object_type":"FunctionObject","name":"diff","module_id":"MapDiff","id":"diff/2","doc":"This is the single function that MapDiff currently exports.\n\n## Examples\n\nIf the (nested) map is still the same, it is considered `:equal`:\n\niex> MapDiff.diff(%{my: 1}, %{my: 1})\n%{changed: :equal, value: %{my: 1}}\n\nWhen a key disappears, it is considered `:removed`:\n\niex> MapDiff.diff(%{a: 1}, %{})\n%{changed: :map_change, value: %{a: %{changed: :removed, value: 1}}}\n\nWhen a key appears, it is considered `:added`:\n\niex> MapDiff.diff(%{}, %{b: 2})\n%{changed: :map_change, value: %{b: %{changed: :added, value: 2}}}\n\nWhen the value of a key changes (and the old nor the new value was a map),\nthen this is considered a `:primitive_change`.\n\niex> MapDiff.diff(%{b: 3}, %{b: 2})\n%{changed: :map_change,\n  value: %{b: %{added: 2, changed: :primitive_change, removed: 3}}}\n\niex> MapDiff.diff(%{val: 3}, %{val: %{}})\n%{changed: :map_change,\n  value: %{val: %{changed: :primitive_change, added: %{}, removed: 3}}}\n\nWhen the value of a key changes, and the old and new values are both maps,\n  then this is considered a `:map_change` that can be parsed recursively.\n\niex> MapDiff.diff(%{a: %{}}, %{a: %{b: 1}})\n%{changed: :map_change,\n  value: %{a: %{changed: :map_change,\n  value: %{b: %{changed: :added, value: 1}}}}}\n\nA more complex example, to see what happens with nested maps:\n\niex> foo = %{a: 1, b: 2, c: %{d: 3, e: 4, f: 5}}\niex> bar = %{a: 1, b: 42, c: %{d: %{something_else: \"entirely\"}, f: 10}}\niex> MapDiff.diff(foo, bar)\n%{changed: :map_change,\n  value: %{a: %{changed: :equal, value: 1},\n    b: %{added: 42, changed: :primitive_change, removed: 2},\n    c: %{changed: :map_change,\n      value: %{d: %{added: %{something_else: \"entirely\"},\n      changed: :primitive_change, removed: 3},\n    e: %{changed: :removed, value: 4},\n    f: %{added: 10, changed: :primitive_change, removed: 5}}}}}\n\n","arity":2}],"language":"elixir","git_repo_url":"https://github.com/Qqwy/elixir_map_diff.git","client_version":"0.5.5","client_name":"inch_ex","branch_name":"master","args":[]}